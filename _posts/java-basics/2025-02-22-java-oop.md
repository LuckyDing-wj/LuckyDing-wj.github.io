---
layout: post
title: "Java 面向对象编程详解"
date: 2025-02-22 22:00:00 +0800
categories: [Java基础]
tags: [Java, OOP, 面向对象]
---

## 一、面向对象概述

面向对象编程（Object-Oriented Programming，OOP）是一种编程范式，它使用"对象"来设计软件。

### 三大核心特性

| 特性 | 说明 |
|------|------|
| **封装** | 隐藏实现细节，对外提供公共访问方式 |
| **继承** | 子类继承父类的属性和方法，实现代码复用 |
| **多态** | 同一个行为具有多个不同表现形式 |

---

## 二、类与对象

### 类的定义

```java
public class Student {
    // 成员变量（属性）
    private String name;
    private int age;
    private String school;

    // 构造方法
    public Student() {
        this.school = "清华大学";
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
        this.school = "清华大学";
    }

    // 成员方法
    public void study() {
        System.out.println(name + "正在学习");
    }

    public void introduce() {
        System.out.println("我叫" + name + "，今年" + age + "岁");
    }

    // getter/setter
    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }
}
```

### 对象的创建与使用

```java
public class Main {
    public static void main(String[] args) {
        // 创建对象
        Student s1 = new Student();
        s1.setName("张三");
        s1.setAge(20);

        // 调用方法
        s1.study();
        s1.introduce();

        // 使用带参构造
        Student s2 = new Student("李四", 21);
        s2.introduce();
    }
}
```

---

## 三、封装

### 访问修饰符

| 修饰符 | 同一类 | 同一包 | 子类 | 所有类 |
|--------|--------|--------|------|--------|
| private | ✅ | ❌ | ❌ | ❌ |
| default | ✅ | ✅ | ❌ | ❌ |
| protected | ✅ | ✅ | ✅ | ❌ |
| public | ✅ | ✅ | ✅ | ✅ |

### 封装示例

```java
public class BankAccount {
    private double balance;  // 私有属性，外部无法直接访问

    public BankAccount(double initialBalance) {
        this.balance = initialBalance;
    }

    // 提供公共的访问方法
    public double getBalance() {
        return balance;
    }

    public void deposit(double amount) {
        if (amount > 0) {
            balance += amount;
            System.out.println("存款成功，余额：" + balance);
        }
    }

    public void withdraw(double amount) {
        if (amount > 0 && amount <= balance) {
            balance -= amount;
            System.out.println("取款成功，余额：" + balance);
        } else {
            System.out.println("取款失败");
        }
    }
}
```

---

## 四、继承

### 基本语法

```java
// 父类
public class Animal {
    protected String name;
    protected int age;

    public Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public void eat() {
        System.out.println(name + "在吃东西");
    }

    public void sleep() {
        System.out.println(name + "在睡觉");
    }
}

// 子类继承父类
public class Dog extends Animal {
    private String breed;  // 品种

    public Dog(String name, int age, String breed) {
        super(name, age);  // 调用父类构造方法
        this.breed = breed;
    }

    // 子类特有方法
    public void bark() {
        System.out.println(name + "在汪汪叫");
    }

    // 方法重写
    @Override
    public void eat() {
        System.out.println(name + "在吃狗粮");
    }
}
```

### super 关键字

```java
public class Cat extends Animal {
    public Cat(String name, int age) {
        super(name, age);  // 调用父类构造方法
    }

    @Override
    public void eat() {
        super.eat();  // 调用父类方法
        System.out.println("猫还爱吃鱼");
    }
}
```

### 方法重写 @Override

```java
@Override
public String toString() {
    return "Dog{name='" + name + "', age=" + age + "}";
}

@Override
public boolean equals(Object obj) {
    if (this == obj) return true;
    if (obj == null || getClass() != obj.getClass()) return false;
    Dog dog = (Dog) obj;
    return age == dog.age && Objects.equals(name, dog.name);
}
```

---

## 五、多态

### 多态的体现

```java
// 父类引用指向子类对象
Animal animal1 = new Dog("旺财", 3, "金毛");
Animal animal2 = new Cat("咪咪", 2);

animal1.eat();  // 调用 Dog 的 eat 方法
animal2.eat();  // 调用 Cat 的 eat 方法
```

### 多态的使用场景

```java
public class AnimalDemo {
    public static void main(String[] args) {
        Animal[] animals = {
            new Dog("旺财", 3, "金毛"),
            new Cat("咪咪", 2),
            new Bird("小黄", 1)
        };

        // 统一处理
        for (Animal animal : animals) {
            animal.eat();
            animal.sleep();
        }
    }
}
```

### instanceof 类型判断

```java
if (animal instanceof Dog) {
    Dog dog = (Dog) animal;  // 向下转型
    dog.bark();
} else if (animal instanceof Cat) {
    Cat cat = (Cat) animal;
    cat.meow();
}
```

---

## 六、抽象类

### 抽象类定义

```java
public abstract class Shape {
    private String color;

    public Shape(String color) {
        this.color = color;
    }

    // 抽象方法：没有方法体，子类必须实现
    public abstract double getArea();
    public abstract double getPerimeter();

    // 普通方法
    public void display() {
        System.out.println("这是一个" + color + "的图形");
    }
}
```

### 抽象类实现

```java
public class Circle extends Shape {
    private double radius;

    public Circle(String color, double radius) {
        super(color);
        this.radius = radius;
    }

    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }

    @Override
    public double getPerimeter() {
        return 2 * Math.PI * radius;
    }
}

public class Rectangle extends Shape {
    private double width;
    private double height;

    public Rectangle(String color, double width, double height) {
        super(color);
        this.width = width;
        this.height = height;
    }

    @Override
    public double getArea() {
        return width * height;
    }

    @Override
    public double getPerimeter() {
        return 2 * (width + height);
    }
}
```

---

## 七、接口

### 接口定义

```java
public interface Flyable {
    // 常量（默认 public static final）
    int MAX_HEIGHT = 10000;

    // 抽象方法（默认 public abstract）
    void fly();
    void land();

    // 默认方法（Java 8+）
    default void glide() {
        System.out.println("滑翔中...");
    }

    // 静态方法（Java 8+）
    static void showInfo() {
        System.out.println("这是飞行接口");
    }
}
```

### 接口实现

```java
public class Bird implements Flyable {
    private String name;

    public Bird(String name) {
        this.name = name;
    }

    @Override
    public void fly() {
        System.out.println(name + "正在飞行");
    }

    @Override
    public void land() {
        System.out.println(name + "正在降落");
    }
}
```

### 多接口实现

```java
public class Airplane implements Flyable, Swimmable {
    @Override
    public void fly() {
        System.out.println("飞机在飞行");
    }

    @Override
    public void land() {
        System.out.println("飞机降落");
    }

    @Override
    public void swim() {
        System.out.println("水上飞机可以滑行");
    }
}
```

---

## 八、内部类

### 成员内部类

```java
public class Outer {
    private int x = 10;

    class Inner {
        private int y = 20;

        public void show() {
            System.out.println("外部类 x = " + x);  // 访问外部类成员
            System.out.println("内部类 y = " + y);
        }
    }

    public void test() {
        Inner inner = new Inner();
        inner.show();
    }
}

// 使用方式
Outer outer = new Outer();
Outer.Inner inner = outer.new Inner();
inner.show();
```

### 静态内部类

```java
public class Outer {
    static int x = 10;

    static class StaticInner {
        void show() {
            System.out.println("x = " + x);  // 只能访问静态成员
        }
    }
}

// 使用方式
Outer.StaticInner inner = new Outer.StaticInner();
inner.show();
```

### 匿名内部类

```java
public interface OnClickListener {
    void onClick();
}

public class Button {
    private OnClickListener listener;

    public void setOnClickListener(OnClickListener listener) {
        this.listener = listener;
    }

    public void click() {
        if (listener != null) {
            listener.onClick();
        }
    }
}

// 使用匿名内部类
Button button = new Button();
button.setOnClickListener(new OnClickListener() {
    @Override
    public void onClick() {
        System.out.println("按钮被点击了");
    }
});
```

---

## 九、Object 类与常用方法

### toString()

```java
@Override
public String toString() {
    return "Person{name='" + name + "', age=" + age + "}";
}
```

### equals() 和 hashCode()

```java
@Override
public boolean equals(Object o) {
    if (this == o) return true;
    if (o == null || getClass() != o.getClass()) return false;
    Person person = (Person) o;
    return age == person.age && Objects.equals(name, person.name);
}

@Override
public int hashCode() {
    return Objects.hash(name, age);
}
```

### clone()

```java
public class Person implements Cloneable {
    @Override
    protected Object clone() throws CloneNotSupportedException {
        return super.clone();
    }
}
```

---

## 十、设计原则

### SOLID 原则

| 原则 | 说明 |
|------|------|
| S - 单一职责 | 一个类只负责一项职责 |
| O - 开闭原则 | 对扩展开放，对修改关闭 |
| L - 里氏替换 | 子类可以替换父类 |
| I - 接口隔离 | 接口应该小而专一 |
| D - 依赖倒置 | 依赖抽象而非具体 |

### 简单工厂模式示例

```java
// 工厂类
public class ShapeFactory {
    public static Shape createShape(String type) {
        switch (type) {
            case "circle":
                return new Circle("红色", 5);
            case "rectangle":
                return new Rectangle("蓝色", 4, 6);
            default:
                throw new IllegalArgumentException("未知类型");
        }
    }
}

// 使用
Shape shape = ShapeFactory.createShape("circle");
System.out.println("面积: " + shape.getArea());
```

---

## 十一、枚举

### 基本枚举

```java
public enum Season {
    SPRING, SUMMER, AUTUMN, WINTER
}

// 使用
Season season = Season.SPRING;
System.out.println(season);        // SPRING
System.out.println(season.name()); // SPRING
System.out.println(season.ordinal()); // 0（序号）

// 遍历
for (Season s : Season.values()) {
    System.out.println(s);
}

// 字符串转枚举
Season s = Season.valueOf("SUMMER");
```

### 带属性和方法的枚举

```java
public enum Planet {
    MERCURY(3.303e+23, 2.4397e6),
    VENUS(4.869e+24, 6.0518e6),
    EARTH(5.976e+24, 6.37814e6);

    private final double mass;
    private final double radius;

    // 构造方法必须是 private
    Planet(double mass, double radius) {
        this.mass = mass;
        this.radius = radius;
    }

    // 表面重力
    public double surfaceGravity() {
        final double G = 6.67300E-11;
        return G * mass / (radius * radius);
    }

    public double getMass() { return mass; }
    public double getRadius() { return radius; }
}
```

### 枚举实现接口

```java
public interface Describable {
    String describe();
}

public enum Color implements Describable {
    RED("红色"), GREEN("绿色"), BLUE("蓝色");

    private final String chinese;

    Color(String chinese) {
        this.chinese = chinese;
    }

    @Override
    public String describe() {
        return "颜色：" + chinese;
    }
}
```

### 枚举用于策略模式

```java
public enum Operation {
    ADD {
        @Override
        public double apply(double a, double b) { return a + b; }
    },
    SUBTRACT {
        @Override
        public double apply(double a, double b) { return a - b; }
    },
    MULTIPLY {
        @Override
        public double apply(double a, double b) { return a * b; }
    },
    DIVIDE {
        @Override
        public double apply(double a, double b) { return a / b; }
    };

    public abstract double apply(double a, double b);
}

// 使用
double result = Operation.ADD.apply(1, 2);  // 3.0
```

---

## 十二、泛型

### 泛型类

```java
public class Box<T> {
    private T content;

    public void put(T item) {
        this.content = item;
    }

    public T get() {
        return content;
    }
}

// 使用
Box<String> stringBox = new Box<>();
stringBox.put("Hello");
String s = stringBox.get();  // 不需要强制转换

Box<Integer> intBox = new Box<>();
intBox.put(123);
```

### 多类型参数

```java
public class Pair<K, V> {
    private K key;
    private V value;

    public Pair(K key, V value) {
        this.key = key;
        this.value = value;
    }

    public K getKey() { return key; }
    public V getValue() { return value; }
}

Pair<String, Integer> pair = new Pair<>("年龄", 25);
```

### 泛型方法

```java
public class GenericMethod {
    // 泛型方法
    public static <T> void printArray(T[] array) {
        for (T item : array) {
            System.out.print(item + " ");
        }
        System.out.println();
    }

    // 有返回值的泛型方法
    public static <T> T getFirst(List<T> list) {
        if (list == null || list.isEmpty()) {
            return null;
        }
        return list.get(0);
    }

    public static void main(String[] args) {
        Integer[] intArr = {1, 2, 3};
        String[] strArr = {"A", "B", "C"};

        printArray(intArr);  // 1 2 3
        printArray(strArr);  // A B C
    }
}
```

### 泛型接口

```java
public interface Repository<T> {
    void save(T entity);
    T findById(int id);
    List<T> findAll();
}

public class UserRepository implements Repository<User> {
    @Override
    public void save(User entity) { /* ... */ }

    @Override
    public User findById(int id) { /* ... */ return null; }

    @Override
    public List<User> findAll() { /* ... */ return null; }
}
```

### 通配符

```java
// 上界通配符：只能读取
public static double sum(List<? extends Number> list) {
    double total = 0;
    for (Number num : list) {
        total += num.doubleValue();
    }
    return total;
}

// 下界通配符：只能写入
public static void addIntegers(List<? super Integer> list) {
    list.add(1);
    list.add(2);
}

// 无界通配符
public static void printList(List<?> list) {
    for (Object item : list) {
        System.out.println(item);
    }
}

// 使用
List<Integer> intList = Arrays.asList(1, 2, 3);
List<Double> doubleList = Arrays.asList(1.1, 2.2);

sum(intList);     // OK
sum(doubleList);  // OK
```

### 类型擦除

```java
// 编译后泛型信息被擦除
// Box<String> 和 Box<Integer> 在运行时是同一个类
Box<String> a = new Box<>();
Box<Integer> b = new Box<>();
System.out.println(a.getClass() == b.getClass());  // true

// 因此不能：
// new T()           — 不能实例化类型参数
// new T[]           — 不能创建泛型数组
// T.class           — 不能获取类型参数的 Class
// instanceof T      — 不能用 instanceof 检查
```

---

## 练习题

1. 定义一个 Person 类，包含姓名、年龄属性，实现 Comparable 接口
2. 使用继承实现不同形状的面积计算
3. 实现一个简单的观察者模式
4. 使用接口实现支付功能（微信、支付宝、银行卡）

---

## 相关链接

- [学习资源汇总](/2025/02/22/learning-resources.html)
- [返回学习路线](/#roadmap)

---

*持续更新中...*

